// <auto-generated>
{{>partial_header}}
{{#nrt}}
#nullable enable

{{/nrt}}
using System;
using System.Collections;
using System.Collections.Generic;
{{^netStandard}}
using System.Diagnostics.CodeAnalysis;
{{/netStandard}}
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;

namespace {{packageName}}
{
    /// <summary>
    /// Remote environment.
    /// </summary>
    {{>visibility}} enum Environment
    {
        Development,
        Production,
    }

    public static class StreamContentExtension
    {
        public static StreamContent From(Stream stream)
        {
            return new StreamContent(stream);
        }

        public static StreamContent From(Stream stream, int bufferSize)
        {
            return new StreamContent(stream, bufferSize);
        }

        public static IEnumerable<StreamContent> From(IEnumerable<Stream> streams)
        {
            var result = new List<StreamContent>();
            foreach (var stream in streams)
                result.Add(new StreamContent(stream));

            return result;
        }
    }

    public static class MultipartContentExtension
    {
        public static void Add(this MultipartContent multipartContent, IEnumerable<StreamContent> streamContents)
        {
            var result = new List<StreamContent>();
            foreach (var streamContent in streamContents)
                result.Add(streamContent);
        }
    }

    public static class Utf8JsonWriterExtension
    {
        public static void WriteString(this Utf8JsonWriter writer, string propertyName, Guid? id)
        {
            writer.WriteString(propertyName, id!.Value);
        }

        public static void WriteNumber(this Utf8JsonWriter writer, string propertyName, int? number)
        {
            writer.WriteNumber(propertyName, number!.Value);
        }

        public static void WriteNumber(this Utf8JsonWriter writer, string propertyName, float? number)
        {
            writer.WriteNumber(propertyName, number!.Value);
        }

        public static void WriteNumber(this Utf8JsonWriter writer, string propertyName, double? number)
        {
            writer.WriteNumber(propertyName, number!.Value);
        }
    }

    public static class DateTimeExtension
    {
        public static string ToString(this DateTime? dateTime, string format)
        {
            return dateTime.GetValueOrDefault().ToString(format);
        }
    }

    /// <summary>
    /// A dictionary in which one key has many associated values.
    /// </summary>
    /// <typeparam name="TKey">The type of the key</typeparam>
    /// <typeparam name="TValue">The type of the value associated with the key.</typeparam>
    public class Multimap<TKey, TValue> : IDictionary<TKey, IList<TValue>>
    {
        #region Private Fields

        private readonly Dictionary<TKey, IList<TValue>> _dictionary;

        #endregion Private Fields

        #region Constructors

        /// <summary>
        /// Empty Constructor.
        /// </summary>
        public Multimap()
        {
            _dictionary = new Dictionary<TKey, IList<TValue>>();
        }

        /// <summary>
        /// Constructor with comparer.
        /// </summary>
        /// <param name="comparer"></param>
        public Multimap(IEqualityComparer<TKey> comparer)
        {
            _dictionary = new Dictionary<TKey, IList<TValue>>(comparer);
        }

        #endregion Constructors

        #region Enumerators

        /// <summary>
        /// To get the enumerator.
        /// </summary>
        /// <returns>Enumerator</returns>
        public IEnumerator<KeyValuePair<TKey, IList<TValue>>> GetEnumerator()
        {
            return _dictionary.GetEnumerator();
        }

        /// <summary>
        /// To get the enumerator.
        /// </summary>
        /// <returns>Enumerator</returns>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return _dictionary.GetEnumerator();
        }

        #endregion Enumerators

        #region Public Members
        /// <summary>
        /// Add values to Multimap
        /// </summary>
        /// <param name="item">Key value pair</param>
        public void Add(KeyValuePair<TKey, IList<TValue>> item)
        {
            if (!TryAdd(item.Key, item.Value))
                throw new InvalidOperationException("Could not add values to Multimap.");
        }

        /// <summary>
        /// Add Multimap to Multimap
        /// </summary>
        /// <param name="multimap">Multimap</param>
        public void Add(Multimap<TKey, TValue> multimap)
        {
            foreach (var item in multimap)
            {
                if (!TryAdd(item.Key, item.Value))
                    throw new InvalidOperationException("Could not add values to Multimap.");
            }
        }

        /// <summary>
        /// Clear Multimap
        /// </summary>
        public void Clear()
        {
            _dictionary.Clear();
        }

        /// <summary>
        /// Determines whether Multimap contains the specified item.
        /// </summary>
        /// <param name="item">Key value pair</param>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        /// <returns>true if the Multimap contains the item; otherwise, false.</returns>
        public bool Contains(KeyValuePair<TKey, IList<TValue>> item)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        ///  Copy items of the Multimap to an array,
        ///     starting at a particular array index.
        /// </summary>
        /// <param name="array">The array that is the destination of the items copied
        ///     from Multimap. The array must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        public void CopyTo(KeyValuePair<TKey, IList<TValue>>[] array, int arrayIndex)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Removes the specified item from the Multimap.
        /// </summary>
        /// <param name="item">Key value pair</param>
        /// <returns>true if the item is successfully removed; otherwise, false.</returns>
        /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
        public bool Remove(KeyValuePair<TKey, IList<TValue>> item)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets the number of items contained in the Multimap.
        /// </summary>
        public int Count => _dictionary.Count;

        /// <summary>
        /// Gets a value indicating whether the Multimap is read-only.
        /// </summary>
        public bool IsReadOnly => false;

        /// <summary>
        /// Adds an item with the provided key and value to the Multimap.
        /// </summary>
        /// <param name="key">The object to use as the key of the item to add.</param>
        /// <param name="value">The object to use as the value of the item to add.</param>
        /// <exception cref="InvalidOperationException">Thrown when couldn't add the value to Multimap.</exception>
        public void Add(TKey key, IList<TValue> value)
        {
            if (value != null && value.Count > 0)
            {
                if (_dictionary.TryGetValue(key, out var list))
                {
                    foreach (var k in value) list.Add(k);
                }
                else
                {
                    list = new List<TValue>(value);
                    if (!TryAdd(key, list))
                        throw new InvalidOperationException("Could not add values to Multimap.");
                }
            }
        }

        /// <summary>
        /// Determines whether the Multimap contains an item with the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the Multimap.</param>
        /// <returns>true if the Multimap contains an item with
        ///     the key; otherwise, false.</returns>
        public bool ContainsKey(TKey key)
        {
            return _dictionary.ContainsKey(key);
        }

        /// <summary>
        /// Removes item with the specified key from the Multimap.
        /// </summary>
        /// <param name="key">The key to locate in the Multimap.</param>
        /// <returns>true if the item is successfully removed; otherwise, false.</returns>
        public bool Remove(TKey key)
        {
            return TryRemove(key, out var _);
        }

        /// <summary>
        /// Gets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key whose value to get.</param>
        /// <param name="value">When this method returns, the value associated with the specified key, if the
        ///     key is found; otherwise, the default value for the type of the value parameter.
        ///     This parameter is passed uninitialized.</param>
        /// <returns> true if the object that implements Multimap contains
        ///     an item with the specified key; otherwise, false.</returns>
        public bool TryGetValue(TKey key, out IList<TValue> value)
        {
            return _dictionary.TryGetValue(key, out value);
        }

        /// <summary>
        /// Gets or sets the item with the specified key.
        /// </summary>
        /// <param name="key">The key of the item to get or set.</param>
        /// <returns>The value of the specified key.</returns>
        public IList<TValue> this[TKey key]
        {
            get => _dictionary[key];
            set => _dictionary[key] = value;
        }

        /// <summary>
        /// Gets a System.Collections.Generic.ICollection containing the keys of the Multimap.
        /// </summary>
        public ICollection<TKey> Keys => _dictionary.Keys;

        /// <summary>
        /// Gets a System.Collections.Generic.ICollection containing the values of the Multimap.
        /// </summary>
        public ICollection<IList<TValue>> Values => _dictionary.Values;

        /// <summary>
        ///  Copy the items of the Multimap to an System.Array,
        ///     starting at a particular System.Array index.
        /// </summary>
        /// <param name="array">The one-dimensional System.Array that is the destination of the items copied
        ///     from Multimap. The System.Array must have zero-based indexing.</param>
        /// <param name="index">The zero-based index in array at which copying begins.</param>
        public void CopyTo(Array array, int index)
        {
            ((ICollection)_dictionary).CopyTo(array, index);
        }

        /// <summary>
        /// Adds an item with the provided key and value to the Multimap.
        /// </summary>
        /// <param name="key">The object to use as the key of the item to add.</param>
        /// <param name="value">The object to use as the value of the item to add.</param>
        /// <exception cref="InvalidOperationException">Thrown when couldn't add value to Multimap.</exception>
        public void Add(TKey key, TValue value)
        {
            if (value != null)
            {
                if (_dictionary.TryGetValue(key, out var list))
                {
                    list.Add(value);
                }
                else
                {
                    list = new List<TValue> { value };
                    if (!TryAdd(key, list))
                        throw new InvalidOperationException("Could not add value to Multimap.");
                }
            }
        }

        #endregion Public Members

        #region Private Members

        /**
            * Helper method to encapsulate generator differences between dictionary types.
            */
        private bool TryRemove(TKey key, out IList<TValue> value)
        {
            _dictionary.TryGetValue(key, out value);
            return _dictionary.Remove(key);
        }

        /**
            * Helper method to encapsulate generator differences between dictionary types.
            */
        private bool TryAdd(TKey key, IList<TValue> value)
        {
            try
            {
                _dictionary.Add(key, value);
            }
            catch (ArgumentException)
            {
                return false;
            }

            return true;
        }
        #endregion Private Members
    }

    public static class HttpResponseHeadersExtension
    {
        public static Multimap<string, string> ToMultimap(this HttpResponseHeaders headers)
        {
            var multimap = new Multimap<string, string>(StringComparer.OrdinalIgnoreCase);
    
            foreach (var header in headers)
            {
                string key = header.Key;
                IList<string> values = header.Value.ToList();
    
                if (multimap.ContainsKey(key))
                {
                    // If the key already exists, merge the values
                    multimap[key] = multimap[key].Concat(values).ToList();
                    continue;
                }

                multimap[key] = values;
            }
    
            return multimap;
        }
    }

    /// <summary>
    /// Provides a non-generic contract for the ApiResponse wrapper.
    /// </summary>
    public interface IApiResponse
    {
        /// <summary>
        /// The data type of <see cref="Content"/>
        /// </summary>
        Type ResponseType { get; }

        /// <summary>
        /// The content of this response
        /// </summary>
        Object Content { get; }

        /// <summary>
        /// Gets or sets the status code (HTTP status code)
        /// </summary>
        /// <value>The status code.</value>
        HttpStatusCode StatusCode { get; }

        /// <summary>
        /// Gets or sets the HTTP headers
        /// </summary>
        /// <value>HTTP headers</value>
        Multimap<string, string> Headers { get; }

        /// <summary>
        /// Gets or sets any error text defined by the calling client.
        /// </summary>
        string ErrorText { get; set; }

        /// <summary>
        /// Gets or sets any cookies passed along on the response.
        /// </summary>
        List<Cookie> Cookies { get; set; }

        /// <summary>
        /// The raw content of this response
        /// </summary>
        string RawContent { get; }
    }

    /// <summary>
    /// API Response
    /// </summary>
    public class ApiResponse<T> : IApiResponse
    {
        #region Properties

        /// <summary>
        /// Gets or sets the status code (HTTP status code)
        /// </summary>
        /// <value>The status code.</value>
        public HttpStatusCode StatusCode { get; }

        /// <summary>
        /// Gets or sets the HTTP headers
        /// </summary>
        /// <value>HTTP headers</value>
        public Multimap<string, string> Headers { get; }

        /// <summary>
        /// Gets or sets the data (parsed HTTP body)
        /// </summary>
        /// <value>The data.</value>
        public T Data { get; }

        /// <summary>
        /// Gets or sets any error text defined by the calling client.
        /// </summary>
        public string ErrorText { get; set; }

        /// <summary>
        /// Gets or sets any cookies passed along on the response.
        /// </summary>
        public List<Cookie> Cookies { get; set; }

        /// <summary>
        /// The content of this response
        /// </summary>
        public Type ResponseType
        {
            get { return typeof(T); }
        }

        /// <summary>
        /// The data type of <see cref="Content"/>
        /// </summary>
        public object Content
        {
            get { return Data; }
        }

        /// <summary>
        /// The raw content
        /// </summary>
        public string RawContent { get; }

        #endregion Properties

        #region Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="headers">HTTP headers.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        /// <param name="rawContent">Raw content.</param>
        public ApiResponse(HttpStatusCode statusCode, Multimap<string, string> headers, T data, string rawContent)
        {
            StatusCode = statusCode;
            Headers = headers;
            Data = data;
            RawContent = rawContent;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="headers">HTTP headers.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        public ApiResponse(HttpStatusCode statusCode, Multimap<string, string> headers, T data) : this(statusCode, headers, data, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        /// <param name="rawContent">Raw content.</param>
        public ApiResponse(HttpStatusCode statusCode, T data, string rawContent) : this(statusCode, null, data, rawContent)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiResponse{T}" /> class.
        /// </summary>
        /// <param name="statusCode">HTTP status code.</param>
        /// <param name="data">Data (parsed HTTP body)</param>
        public ApiResponse(HttpStatusCode statusCode, T data) : this(statusCode, data, null)
        {
        }

        #endregion Constructors
    }    

    /// <summary>
    /// Provides a non-generic contract for the ApiResponse wrapper.
    /// </summary>
    {{>visibility}} partial interface __IApiResponse
    {
        /// <summary>
        /// The IsSuccessStatusCode from the api response
        /// </summary>
        bool IsSuccessStatusCode { get; }

        /// <summary>
        /// Gets the status code (HTTP status code)
        /// </summary>
        /// <value>The status code.</value>
        HttpStatusCode StatusCode { get; }

        /// <summary>
        /// The raw content of this response.
        /// </summary>
        string RawContent { get; }

        /// <summary>
        /// The DateTime when the request was retrieved.
        /// </summary>
        DateTime DownloadedAt { get; }

        /// <summary>
        /// The headers contained in the api response
        /// </summary>
        System.Net.Http.Headers.HttpResponseHeaders Headers { get; }

        /// <summary>
        /// The path used when making the request.
        /// </summary>
        string Path { get; }

        /// <summary>
        /// The reason phrase contained in the api response
        /// </summary>
        string{{nrt?}} ReasonPhrase { get; }

        /// <summary>
        /// The DateTime when the request was sent.
        /// </summary>
        DateTime RequestedAt { get; }

        /// <summary>
        /// The Uri used when making the request.
        /// </summary>
        Uri{{nrt?}} RequestUri { get; }
    }

    /// <summary>
    /// API Response
    /// </summary>
    {{>visibility}} partial class __ApiResponse : __IApiResponse
    {
        /// <summary>
        /// Gets the status code (HTTP status code)
        /// </summary>
        /// <value>The status code.</value>
        public HttpStatusCode StatusCode { get; }

        /// <summary>
        /// The raw data
        /// </summary>
        public string RawContent { get; protected set; }

        /// <summary>
        /// The IsSuccessStatusCode from the api response
        /// </summary>
        public bool IsSuccessStatusCode { get; }

        /// <summary>
        /// The reason phrase contained in the api response
        /// </summary>
        public string{{nrt?}} ReasonPhrase { get; }

        /// <summary>
        /// The headers contained in the api response
        /// </summary>
        public System.Net.Http.Headers.HttpResponseHeaders Headers { get; }

        /// <summary>
        /// The DateTime when the request was retrieved.
        /// </summary>
        public DateTime DownloadedAt { get; } = DateTime.UtcNow;

        /// <summary>
        /// The DateTime when the request was sent.
        /// </summary>
        public DateTime RequestedAt { get; }

        /// <summary>
        /// The path used when making the request.
        /// </summary>
        public string Path { get; }

        /// <summary>
        /// The Uri used when making the request.
        /// </summary>
        public Uri{{nrt?}} RequestUri { get; }

        /// <summary>
        /// The <see cref="System.Text.Json.JsonSerializerOptions"/>
        /// </summary>
        protected System.Text.Json.JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// Construct the response using an HttpResponseMessage
        /// </summary>
        /// <param name="httpRequestMessage"></param>
        /// <param name="httpResponseMessage"></param>
        /// <param name="rawContent"></param>
        /// <param name="path"></param>
        /// <param name="requestedAt"></param>
        /// <param name="jsonSerializerOptions"></param>
        public __ApiResponse(System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions)
        {
            StatusCode = httpResponseMessage.StatusCode;
            Headers = httpResponseMessage.Headers;
            IsSuccessStatusCode = httpResponseMessage.IsSuccessStatusCode;
            ReasonPhrase = httpResponseMessage.ReasonPhrase;
            RawContent = rawContent;
            Path = path;
            RequestUri = httpRequestMessage.RequestUri;
            RequestedAt = requestedAt;
            _jsonSerializerOptions = jsonSerializerOptions;
            OnCreated(httpRequestMessage, httpResponseMessage);
        }

        partial void OnCreated(System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);
    }

    /// <summary>
    /// An interface for responses of type Ok.
    /// </summary>
    /// <typeparam name="TType"></typeparam>
    {{>visibility}} interface IOk<TType> : __IApiResponse
    {
        /// <summary>
        /// Deserializes the response if the response is Ok.
        /// </summary>
        /// <returns></returns>
        TType Ok();

        /// <summary>
        /// Returns true if the response is Ok and the deserialized response is not null.
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        bool TryOk({{^netStandard}}[NotNullWhen(true)]{{/netStandard}}out TType{{nrt?}} result);
    }

    /// <summary>
    /// An interface for responses of type Unauthorized.
    /// </summary>
    /// <typeparam name="TType"></typeparam>
    {{>visibility}} interface IUnauthorized<TType> : __IApiResponse
    {
        /// <summary>
        /// Deserializes the response if the response is Unauthorized.
        /// </summary>
        /// <returns></returns>
        TType Unauthorized();

        /// <summary>
        /// Returns true if the response is Unauthorized and the deserialized response is not null.
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        bool TryUnauthorized({{^netStandard}}[NotNullWhen(true)]{{/netStandard}}out TType{{nrt?}} result);
    }

    /// <summary>
    /// An interface for responses of type BadRequest.
    /// </summary>
    /// <typeparam name="TType"></typeparam>
    {{>visibility}} interface IBadRequest<TType> : __IApiResponse
    {
        /// <summary>
        /// Deserializes the response if the response is BadRequest.
        /// </summary>
        /// <returns></returns>
        TType BadRequest();

        /// <summary>
        /// Returns true if the response is BadRequest and the deserialized response is not null.
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        bool TryBadRequest({{^netStandard}}[NotNullWhen(true)]{{/netStandard}}out TType{{nrt?}} result);
    }

    /// <summary>
    /// An interface for responses of type NotFound.
    /// </summary>
    /// <typeparam name="TType"></typeparam>
    {{>visibility}} interface INotFound<TType> : __IApiResponse
    {
        /// <summary>
        /// Deserializes the response if the response is NotFound.
        /// </summary>
        /// <returns></returns>
        TType NotFound();

        /// <summary>
        /// Returns true if the response is NotFound and the deserialized response is not null.
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        bool TryNotFound({{^netStandard}}[NotNullWhen(true)]{{/netStandard}}out TType{{nrt?}} result);
    }

    /// <summary>
    /// An interface for responses of type InternalServerError.
    /// </summary>
    /// <typeparam name="TType"></typeparam>
    {{>visibility}} interface IInternalServerError<TType> : __IApiResponse
    {
        /// <summary>
        /// Deserializes the response if the response is InternalServerError.
        /// </summary>
        /// <returns></returns>
        TType InternalServerError();
    
        /// <summary>
        /// Returns true if the response is InternalServerError and the deserialized response is not null.
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        bool TryInternalServerError({{^netStandard}}[NotNullWhen(true)]{{/netStandard}}out TType{{nrt?}} result);
    }
    
    /// <summary>
    /// An interface for responses of type Forbidden.
    /// </summary>
    /// <typeparam name="TType"></typeparam>
    {{>visibility}} interface IForbidden<TType> : __IApiResponse
    {
        /// <summary>
        /// Deserializes the response if the response is Forbidden.
        /// </summary>
        /// <returns></returns>
        TType Forbidden();
    
        /// <summary>
        /// Returns true if the response is Forbidden and the deserialized response is not null.
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        bool TryForbidden({{^netStandard}}[NotNullWhen(true)]{{/netStandard}}out TType{{nrt?}} result);
    }
    
    /// <summary>
    /// An interface for responses of type NotImplemented.
    /// </summary>
    /// <typeparam name="TType"></typeparam>
    {{>visibility}} interface INotImplemented<TType> : __IApiResponse
    {
        /// <summary>
        /// Deserializes the response if the response is NotImplemented.
        /// </summary>
        /// <returns></returns>
        TType NotImplemented();
    
        /// <summary>
        /// Returns true if the response is NotImplemented and the deserialized response is not null.
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        bool TryNotImplemented({{^netStandard}}[NotNullWhen(true)]{{/netStandard}}out TType{{nrt?}} result);
    }
}
